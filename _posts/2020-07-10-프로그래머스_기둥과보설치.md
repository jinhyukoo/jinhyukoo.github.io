---
title: 프로그래머스 2020 KAKAO BLIND REQRUITMENT 기둥과보설치 C++
layout: post
date: '2020-07-10 22:33:00'
author: 진혀크
tags: 프로그래머스 2020 KAKAO BLIND REQRUITMENT 기둥과보설치
cover: "/assets/instacode.png"
categories: 프로그래머스
---

아 진짜 억울하지만 남을 탓할 수 없는 문제... 로직을 정확히 맞췄으나 마지막 answer를 오름차순으로 return하지 못해서 틀린 문제... 이 참에 구조체 정렬에 대해 좀 더 정확히 알아두자...

## 문제설명
빙하가 깨지면서 스노우타운에 떠내려 온 죠르디는 인생 2막을 위해 주택 건축사업에 뛰어들기로 결심하였습니다. 죠르디는 기둥과 보를 이용하여 벽면 구조물을 자동으로 세우는 로봇을 개발할 계획인데, 그에 앞서 로봇의 동작을 시뮬레이션 할 수 있는 프로그램을 만들고 있습니다.
프로그램은 2차원 가상 벽면에 기둥과 보를 이용한 구조물을 설치할 수 있는데, 기둥과 보는 길이가 1인 선분으로 표현되며 다음과 같은 규칙을 가지고 있습니다.

* 기둥은 바닥 위에 있거나 보의 한쪽 끝 부분 위에 있거나, 또는 다른 기둥 위에 있어야 합니다.
* 보는 한쪽 끝 부분이 기둥 위에 있거나, 또는 양쪽 끝 부분이 다른 보와 동시에 연결되어 있어야 합니다.
* 단, 바닥은 벽면의 맨 아래 지면을 말합니다.

2차원 벽면은 n x n 크기 정사각 격자 형태이며, 각 격자는 1 x 1 크기입니다. 맨 처음 벽면은 비어있는 상태입니다. 기둥과 보는 격자선의 교차점에 걸치지 않고, 격자 칸의 각 변에 정확히 일치하도록 설치할 수 있습니다. 다음은 기둥과 보를 설치해 구조물을 만든 예시입니다.

<img src="{{ site.baseurl }}/assets/kakao_kibo.png" width = "80%" height ="80%" title="Problem Picture" class="picture">

예를 들어, 위 그림은 다음 순서에 따라 구조물을 만들었습니다.

1. (1, 0)에서 위쪽으로 기둥을 하나 설치 후, (1, 1)에서 오른쪽으로 보를 하나 만듭니다.
2. (2, 1)에서 위쪽으로 기둥을 하나 설치 후, (2, 2)에서 오른쪽으로 보를 하나 만듭니다.
3. (5, 0)에서 위쪽으로 기둥을 하나 설치 후, (5, 1)에서 위쪽으로 기둥을 하나 더 설치합니다.
4. (4, 2)에서 오른쪽으로 보를 설치 후, (3, 2)에서 오른쪽으로 보를 설치합니다.

만약 (4, 2)에서 오른쪽으로 보를 먼저 설치하지 않고, (3, 2)에서 오른쪽으로 보를 설치하려 한다면 2번 규칙에 맞지 않으므로 설치가 되지 않습니다. 기둥과 보를 삭제하는 기능도 있는데 기둥과 보를 삭제한 후에 남은 기둥과 보들 또한 위 규칙을 만족해야 합니다. 만약, 작업을 수행한 결과가 조건을 만족하지 않는다면 해당 작업은 무시됩니다.

벽면의 크기 n, 기둥과 보를 설치하거나 삭제하는 작업이 순서대로 담긴 2차원 배열 build_frame이 매개변수로 주어질 때, 모든 명령어를 수행한 후 구조물의 상태를 return 하도록 solution 함수를 완성해주세요.
## 제한 사항
* n은 5 이상 100 이하인 자연수입니다.
* build_frame의 세로(행) 길이는 1 이상 1,000 이하입니다.
* build_frame의 가로(열) 길이는 4입니다.
* build_frame의 원소는 [x, y, a, b]형태입니다.
  * x, y는 기둥, 보를 설치 또는 삭제할 교차점의 좌표이며, [가로 좌표, 세로 좌표] 형태입니다.
  * a는 설치 또는 삭제할 구조물의 종류를 나타내며, 0은 기둥, 1은 보를 나타냅니다.
  * b는 구조물을 설치할 지, 혹은 삭제할 지를 나타내며 0은 삭제, 1은 설치를 나타냅니다.
  * 벽면을 벗어나게 기둥, 보를 설치하는 경우는 없습니다.
  * 바닥에 보를 설치 하는 경우는 없습니다.
* 구조물은 교차점 좌표를 기준으로 보는 오른쪽, 기둥은 위쪽 방향으로 설치 또는 삭제합니다.
* 구조물이 겹치도록 설치하는 경우와, 없는 구조물을 삭제하는 경우는 입력으로 주어지지 않습니다.
* 최종 구조물의 상태는 아래 규칙에 맞춰 return 해주세요.
  * return 하는 배열은 가로(열) 길이가 3인 2차원 배열로, 각 구조물의 좌표를 담고있어야 합니다.
  * return 하는 배열의 원소는 [x, y, a] 형식입니다.
  * x, y는 기둥, 보의 교차점 좌표이며, [가로 좌표, 세로 좌표] 형태입니다.
  * 기둥, 보는 교차점 좌표를 기준으로 오른쪽, 또는 위쪽 방향으로 설치되어 있음을 나타냅니다.
  * a는 구조물의 종류를 나타내며, 0은 기둥, 1은 보를 나타냅니다.
  * return 하는 배열은 x좌표 기준으로 오름차순 정렬하며, x좌표가 같을 경우 y좌표 기준으로 오름차순 정렬해주세요.
  * x, y좌표가 모두 같은 경우 기둥이 보보다 앞에 오면 됩니다.

## 예제

|n|build_frame|result|
|:--:|:--------------------|:-----------|
|5|[[1,0,0,1],[1,1,1,1],[2,1,0,1],[2,2,1,1],[5,0,0,1],[5,1,0,1],[4,2,1,1],[3,2,1,1]]|[[1,0,0],[1,1,1],[2,1,0],[2,2,1],[3,2,1],[4,2,1],[5,0,0],[5,1,0]]|
|5|[[0,0,0,1],[2,0,0,1],[4,0,0,1],[0,1,1,1],[1,1,1,1],[2,1,1,1],[3,1,1,1],[2,0,0,0],[1,1,1,0],[2,2,0,1]]|[[0,0,0],[0,1,1],[1,1,1],[2,1,1],[3,1,1],[4,0,0]]|

## 접근

* n의 크기가 작아서 특별한 알고리즘이 필요해보이진 않았다. 다만 제한사항이 주어진 시간 안에 정확하게 구현해내는 것이 중요할 것 같았다.
* 문제에서 준 제한사항들에 대해 정리해가며 수도코드를 짜고 본격적으로 코드를 짜기 시작했다.

## 내가 생각한 풀이

* 설치를 할 때는 문제에서 알려준 조건을 잘 지키는 지 확인하고 지키면 설치를 해준다.
* 제거를 할 때는 제거된 기둥이나 보에 영향을 받는 주변 기둥과 보에 대해 문제에서 알려준 조건을 잘 지키는지 다시 검사를 진행하고 문제가 없으면 삭제하고 문제가 있으면 continue 시킨다.

## 코드

    #include <string>
    #include <vector>
    #include <iostream>
    #include <algorithm>
    int N;
    bool check(int y, int x)
    {
      return (y>=0 && x>=0 && y<=N && x<=N);
    }
    using namespace std;

    int map[101][101][2] = {0, }; //map[y][x][0] 에는 기둥, map[y][x][1]에는 보에 대한 정보 입력하기
    bool check_k(int y, int x) //기둥 체크
    {
      //1을 리턴하면 설치 가능
      if(y == 0) return 1;
      if(check(y-1, x) && map[y-1][x][0]) return 1;
      if(map[y][x-1][1]) return 1;
      if(map[y][x][1]) return 1;
      return 0;
    }

    bool check_b(int y, int x) //보 체크
    {
      //1을 리턴하면 설치 가능
      if((check(y,x-1) && map[y][x-1][1]) && (check(y, x+1) && map[y][x+1][1])) return 1;
      if(map[y-1][x][0]) return 1;
      if(map[y-1][x+1][0]) return 1;
      return 0;
    }

    vector<vector<int>> solution(int n, vector<vector<int>> build_frame) {
      vector<vector<int>> answer;
      N = n;
      for(int i = 0 ; i<build_frame.size() ; i++)
      {
          int x = build_frame[i][0], y = build_frame[i][1];
          if(build_frame[i][2]) // 보
          {
              if(build_frame[i][3]) //설치
              {
                  if(check_b(y,x)) map[y][x][1] = 1;
              }
              else //삭제
              {
                  //보를 삭제할 때 봐야 할 것
                  //좌우에 있는 보와 보에 설치된 기둥들이 조건을 충족시키는지 확인할 것
                  //삭제할 보가 x,y라고 했을 때 x-1,y, x+1,y에 있는 보와, x,y, x+1,y에 있는 기둥이 조건을 충족하는지 확인할 것
                  //map에서 그 부분에 대한 정보를 없애고 4가지 케이스에 대해 1을 return 하는지 확인
                  map[y][x][1] = 0;
                  if(map[y][x-1][1])
                  {
                      if(!check_b(y,x-1))
                      {
                          map[y][x][1] = 1;
                          continue;
                      }
                  }
                  if(map[y][x+1][1])
                  {
                      if(!check_b(y,x+1))
                      {
                          map[y][x][1] = 1;
                          continue;
                      }
                  }
                  if(map[y][x][0])
                  {
                      if(!check_k(y,x))
                      {
                          map[y][x][1] = 1;
                          continue;
                      }
                  }
                  if(map[y][x+1][0])
                  {
                      if(!check_k(y,x+1))
                      {
                          map[y][x][1] = 1;
                          continue;
                      }
                  }
              }
          }
          else // 기둥
          {
              //기둥을 삭제할 때 봐야 할 것
              //기둥을 삭제한 후 기둥과 연결되어 있던 보들이 보를 세울 때 봐야 할 기준을 충족시키는가
              //삭제할 기둥이 x,y라고 했을 때 x,y+1, x-1,y+1 에 보가 있다면 기준을 충족하는지 확인할 것, x,y+1에 있는 기둥이 기준을 충족하는지 확인할 것
              //map에서 그 부분에 대한 정보를 없애고 3가지 케이스에 대해 1을 return 하는지 확인
              if(build_frame[i][3]) //설치
              {
                  if(check_k(y,x)) map[y][x][0] = 1;
              }
              else //삭제
              {
                  map[y][x][0] = 0;
                  if(map[y+1][x][0])
                  {
                      if(!check_k(y+1,x))
                      {
                          map[y][x][0] = 1;
                          continue;
                      }
                  }
                  if(map[y+1][x-1][1])
                  {
                      if(!check_b(y+1,x-1))
                      {
                          map[y][x][0] = 1;
                          continue;
                      }
                  }
                  if(map[y+1][x][1])
                  {
                      if(!check_b(y+1,x))
                      {
                          map[y][x][0] = 1;
                          continue;
                      }
                  }
              }
          }
      }
      //완성한 맵을 돌며 정보 넣어주기
      for(int i = 0 ; i<=n ; i++)
      {
          for(int j = 0 ; j<=n ; j++)
          {
              if(map[j][i][0]) answer.push_back({i,j,0});
              if(map[j][i][1]) answer.push_back({i,j,1});
          }
      }

      return answer;
    }

## 부족했던 점
* x,y,a 순으로 내림차순 정렬을 해야 한다는 조건을 보고 처음에 맵을 탐색하는 for문을 어떻게 돌릴까 하다가 그냥 구조체에 값들을 넣고 정렬하기로 했다.
  * 문제는 구조체 정렬을 제대로 해내지 못했다는 것이다. 이것도 모르고 로직이 문제인가 하고 몇 시간동안 로직만 들여다보고 있었다.
  * 아무리 생각해도 로직에 문제가 없는 것 같아서 구조체에 넣는 방법을 위의 코드와 같이 변경했더니 정답으로 통과가 됐다.

    bool cmp(const data &p1, const data &p2){
      if(p1.x < p2.x){
          return true;
      }
      else if(p1.x == p2.x){
          return p1.y < p2.y;
      }
      else if(p1.x == p2.x && p1.y == p2.y)
      {
          return p1.a < p2.a;
      }
      else{
          return false;
      }
    }

* 위와 같은 cmp 함수를 통해 sort(v.begin(), v.end(), cmp)를 하면 x,y,a 순으로 정렬을 해주는 줄 알았는데 아닌가보다... 로컬에서 테스트 해본 결과 맞게 나와서 이렇게 하면 정렬이 되는 줄 알았다. 자세히 알아봐야 할 것 같다.
