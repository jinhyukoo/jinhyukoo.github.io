---
title: 백준 1068 트리
layout: post
date: '2019-11-24 01:11:00'
author: 진혀크
tags: 백준 1068 트리
cover: "/assets/instacode.png"
categories: BJ
---

## 문제
* 흑백 영상을 압축하여 표현하는 데이터 구조로 쿼드 트리(Quad Tree)라는 방법이 있다. 흰 점을 나타내는 0과 검은 점을 나타내는 1로만 이루어진 영상(2차원 배열)에서 같은 숫자의 점들이 한 곳에 많이 몰려있으면, 쿼드 트리에서는 이를 압축하여 간단히 표현할 수 있다.

주어진 영상이 모두 0으로만 되어 있으면 압축 결과는 "0"이 되고, 모두 1로만 되어 있으면 압축 결과는 "1"이 된다. 만약 0과 1이 섞여 있으면 전체를 한 번에 나타내지를 못하고, 왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른쪽 아래, 이렇게 4개의 영상으로 나누어 압축하게 되며, 이 4개의 영역을 압축한 결과를 차례대로 괄호 안에 묶어서 표현한다

<img src="{{ site.baseurl }}/assets/1992_picture.png" title="Problem Picture" class="picture">

위 그림에서 왼쪽의 영상은 오른쪽의 배열과 같이 숫자로 주어지며, 이 영상을 쿼드 트리 구조를 이용하여 압축하면 "(0(0011)(0(0111)01)1)"로 표현된다.  N ×N 크기의 영상이 주어질 때, 이 영상을 압축한 결과를 출력하는 프로그램을 작성하시오.

## 입력
* 첫째 줄에는 영상의 크기를 나타내는 숫자 N 이 주어진다. N 은 언제나 2의 제곱수로 주어지며, 1≤N ≤64의 범위를 가진다. 두 번째 줄부터는 길이 N 의 문자열이 N 개 들어온다. 각 문자열은 0 또는 1의 숫자로 이루어져 있으며, 영상의 각 점들을 나타낸다.

## 출력
* 영상을 압축한 결과를 출력한다.

## 예제

    예제 입력
    8
    11110000
    11110000
    00011100
    00011100
    11110000
    11110000
    11110011
    11110011

    예제 출력
    2

## 접근

* 트리를 만드는 것은 기본이고, 제거되는 노드를 어떻게 처리 할까 고민을 했다.
  - BFS를 통해 트리를 탐색할 예정이었으므로 제거되는 노드가 나오면 건너뛰고 탐색을 계속 진행하는 알고리즘을 생각했다.
* 리프 노드의 count는 어떻게 할 것인가?

## 내가 생각한 풀이

* 접근에서 생각했던 것과 같은 방법으로 BFS를 실행한다.
* 더 이상 push가 진행되지 않는다면 leaf 노드이므로 count를 해준다.

## 미처 생각하지 못했던것

* root 노드가 제거되면 무조건 0이 되는게 맞는데 이 쉬운걸 깜빡하고 있었다... 다른 로직은 바로 맞게 짰으나 5번인가 틀리고 성공...ㅠㅠ
* 웃긴건 root 노드를 제거하는 TC를 스스로 만들어놓고도 간과하고 넘어갔다 ㅋㅋㅋ

## 코드

    #include<iostream>
    #include<vector>
    #include<queue>
    using namespace std;
    int main(void){
      int N, del, root, r=0;
      vector<int> v[51];
      cin>>N;
      for(int i = 0 ;i<N;i++){
        int t;
        cin>>t;
        if(t != -1){v[t].push_back(i);v[i].push_back(t);}
        else root = i;
      }
      cin>>del;
      if(N==1 || del==root){ //root가 삭제될 경우 무조건 0이 되야 한다는 쉬운 사실을 왜 깜빡하고 있었을까...? 매우 멍청쓰했당 ㅠ
        cout<<0;
        return 0;
      }
      queue<int> q;
      bool chk[51] = {0, };
      q.push(root);
      chk[root] = 1;
      while(!q.empty()){
        int t = q.front(), flag = 0;
        q.pop();
        for(int i = 0 ;i<v[t].size();i++){
          if(chk[v[t][i]] == 0 && v[t][i] != del){
            q.push(v[t][i]);
            chk[v[t][i]] = 1;
            flag = 1;
          }
        }
        if(flag == 0){r++;}
      }
      cout<<r;
      return 0;
    }
