---
title: 백준 16287 Parcel(2018년도 ACM-ICPC문제)
layout: post
date: '2019-10-03 01:42:00'
author: 진혀크
tags: 백준 16287 Parcel ACM-ICPC
cover: "/assets/instacode.png"
categories: BJ
---

ACM-ICPC의 클라스를 느꼈다... 그리고 세상엔 대단한 사람들이 참 많다...

## 문제
* 국제대학소포센터(ICPC: International Collegiate Parcel Center)는 전세계 대학생들을 대상으로 소포 무료 배송 이벤트를 진행하고 있다. 무료 배송 조건은 보낼 소포가 물품 4개로 구성되어야 하며 이들 물품의 무게 합이 정확히 정해진 정수 무게 w 그램이어야 한다는 것이다.

부산대학교에 있는 찬수는 영국 왕립대학에 있는 수환에게 보낼 물품이 매우 많이 있는데, 각 물품의 무게(모두 정수 그램)는 모두 다르다. 이 이벤트는 한시적으로 진행되는 이벤트이기 때문에 찬수는 자신이 보낼 물품 중에서 이 조건을 만족하는 물품 4개가 있는지 가능하면 빨리 알아내고 싶다. 다시 말해서 서로 다른 n(n ≥ 4)개의 정수로 이루어진 집합 A에서 4개의 원소만 꺼내어 만든 부분집합 B(ㅣBㅣ = 4)가 B에 포함된 원소의 수가 w와 일치하는(특수문자가 안 들어가서 수정좀 했습니다...) 조건을 만족하는지 판단하려고 한다.

주어진 w와 A에 대해서, 위 조건을 만족하는 부분집합 B가 존재하면 YES를, 아니면 NO를 출력하는 프로그램을 작성하시오.


## 입력
* 입력은 표준입력을 사용한다. 입력의 첫 줄에는 무게 w(10 ≤ w ≤ 799,994)와 A의 원소 개수 n(4 ≤ n ≤ 5,000)이 공백으로 분리되어 주어진다. 다음 줄에는 A의 원소인 n개의 정수 ai ∈ A(1 ≤ i ≤ n)가 공백으로 분리되어 주어진다. 각 원소 ai는 1이상 200,000이하이다(1 ≤ ai ≤ 200,000).

## 출력
* 출력은 표준출력을 사용한다. 문제의 조건에 따라 YES나 NO를 한 줄에 출력한다.

## 예제

    예제 입력
    10 6
    5 10 7 3 2 1

    예제 출력
    NO

    예제 입력
    21 7
    10 1 4 6 2 8 5

    예제 출력
    YES

## 접근

* 가장 먼저 생각난 방법은 브루트 포스이다. 하지만 Worst Case(5000*5000*5000*5000)를 생각했을 때 제한시간인 4초를 훌쩍 넘기기 때문에 Pass!
* 숫자가 4개이면 2개씩 짝지으면 어떨까?

## 내가 생각한 풀이

* 2개씩 짝지으면 시간을 만족하는가?
  - 5000*5000 = 25000000이므로 약 2500ms 4초를 충분히 만족한다!
* 2개씩 짝짓는 규칙은?
  - 그냥 이중 for문을 사용하여 전체를 한 번씩 구한다!
* 중복되는 게 있을 수 있겠는데?
  - 구조체를 선언하여 풀었다. 구조체에는 두 수의 합, 각각의 수 총 3개의 변수가 들어있다.
* 두 수의 합을 모두 구했으면 구조체 배열을 차례대로 확인해가며 조건에 맞는 경우가 있는지 확인한다.
  - 예를 들어 원하는 숫자가 10이고 구조체의 합이 4이면 합중에 6이 있는지 확인한다.
  - 만약 있다면 두 수를 이루는 모든 숫자가 다른지 확인한다. (각 물품의 무게는 모두 다르므로 이렇게만 확인해도 된다.)

## 문제를 풀면서 힘들었던 점

* 처음엔 4중 for문 말고 생각이 안 났다. 또한 중복 여부를 처음에 생각을 못했었다..ㅠ 가장 힘들었던 점이라면 나의 실력이 부족했던 점...?ㅎ


## 코드

    #include<bits/stdc++.h>
    using namespace std;
    struct data{
      int value;
      int a;
      int b;
    };
    int main(void){
      int w,c,n[5001],min,max,r=0;
      cin>>w>>c;
      for(int i=0 ;i<c;i++){
        cin>>n[i];
      }
      sort(n,n+c);
      min = n[0]; max = n[c];
      vector<struct data> dp[800001];
      bool check[800001] = {0, };
      for(int i = 0 ;i<c;i++){
        for(int j = i+1;j<c;j++){
          struct data temp;
          temp.value = n[i]+n[j];
          temp.a = n[i];
          temp.b = n[j];
          dp[temp.value].push_back(temp);
          check[temp.value] = 1;
        }
      }
      for(int i = 1 ;i<=w/2;i++){
        if(check[i]==1 && check[w-i]==1){
          for(int j = 0; j<dp[i].size();j++){
            for(int k = 0;k<dp[w-i].size();k++){
              if(((dp[i][j].a != dp[w-i][k].a) && (dp[i][j].b != dp[w-i][k].b)) && ((dp[i][j].a != dp[w-i][k].b) && (dp[i][j].b != dp[w-i][k].a))){r=1; break;}
            }
          }
        }
      }
      if(r==1) cout<<"YES";
      else cout<<"NO";
      return 0;
    }
